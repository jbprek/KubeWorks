#Check 1: Pod with Legacy Logs
A Pod in the mcp namespace has a single container named random that writes its logs to the /var/log/random.log file. Add a second container named second that uses the busybox image to allow the following command to display the logs written to the random container's /var/log/random.log file:

kubectl -n mcp logs random second

```angular2html
# A Pod in the mcp namespace has a single container named random hat writes its logs to the /var/log/random.log file. Add a second container named second that uses the busybox image to allow the following command to display the logs written to the random container's /var/log/random.log file: kubectl -n mcp logs random second

# Start by saving the original Pod manifest so you don't lose any information
kubectl -n mcp get pod random -o yaml > original.yaml

# Create a copy for you to modify
cp original.yaml second.yaml

# Edit the file to be equivalent to the following 
cat << EOF > second.yaml
apiVersion: v1
kind: Pod
metadata:
  name: random
  namespace: mcp
spec:
  containers:
  - args:
    - /bin/sh
    - -c
    - while true; do shuf -i 0-1 -n 1 >> /var/log/random.log; sleep 1; done
    image: busybox
    name: random
    volumeMounts:
    - mountPath: /var/log
      name: logs
  - name: second
    image: busybox
    args: [/bin/sh, -c, 'tail -n+1 -f /var/log/random.log']
    volumeMounts:
    - name: logs
      mountPath: /var/log
  volumes:
  - name: logs
    emptyDir: {}
EOF

# Delete the original Pod
kubectl delete -f second.yaml

# Create the modified version
kubectl create -f second.yaml
```

#Check 2: Multi Container Pod Networking
The following multi-container Pod manifest needs to be updated BEFORE being deployed. Container c2 is designed to make HTTP requests to container c1. Before deploying this manifest, update it by substituting the <REPLACE_HOST_HERE> placeholder with the correct host or IP address - the remaining parts of the manifest must remain unchanged. Once deployed - confirm that the solution works correctly by executing the command kubectl logs -n app1 webpod -c c2 > /home/ubuntu/webpod-log.txt. The resulting /home/ubuntu/webpod-log.txt file should contain a single string within it.

Multi-Container Pod Manifest:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: webpod
namespace: app1
spec:
restartPolicy: Never
volumes:
- name: vol1
  emptyDir: {}
containers:
- name: c1
  image: nginx
  volumeMounts:
  - name: vol1
    mountPath: /usr/share/nginx/html
    lifecycle:
    postStart:
    exec:
    command:
    - "bash"
    - "-c"
    - |
    date | sha256sum | tr -d " *-" > /usr/share/nginx/html/index.html
- name: c2
  image: appropriate/curl
  command: ["/bin/sh", "-c", "curl -s http://<REPLACE_HOST_HERE> && sleep 3600"]
  
```
  




#Check 3: Add New Container with ReadOnly Volume
  Update and deploy the provided /home/ubuntu/md5er-app.yaml manifest file, adding a second container named c2 to the existing md5er Pod. The c2 container will run the same bash image that the c1 container already uses. The c2 container must mount the existing vol1 volume in read only mode, and such that it can execute the following bash script:

for word in $(</data/file.txt)
do
echo $word | md5sum | awk '{print $1}'
done
Note: The above command will simply generate an MD5 hash for each individual word found within the /data/file.txt file (generated by the c1 container).

Once deployed, run the following command to save the stdout output of the c2 container:

kubectl logs -n app2 md5er c2 > /home/ubuntu/md5er-output.log

```
apiVersion: v1
kind: Pod
metadata:
name: md5er
namespace: app2
spec:
restartPolicy: Never
volumes:
- name: vol1
  emptyDir: {}
  containers:
- name: c1
  image: bash
  env:
  - name: DATA
    valueFrom:
    configMapKeyRef:
    name: cm1
    key: data
    volumeMounts:
  - name: vol1
    mountPath: /data
    command: ["/usr/local/bin/bash", "-c", "echo $DATA > /data/file.txt"]  
```

```
command:
- "/usr/local/bin/bash"
- "-c"
  - |
    for word in $(</data/file.txt)
    do
    echo $word | md5sum | awk '{print $1}'
    done
```